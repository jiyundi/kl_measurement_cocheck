import numpy as np
import os
from pathlib import Path

from astropy.cosmology import FlatLambdaCDM
from astropy.coordinates import SkyCoord
from astropy.io import fits
import astropy.units as u
from astropy.wcs import WCS
import galsim

def check_dir(file_basename):
    '''
    Checks if directories in file basename exist and creates them if they don't

    Args:
        path (string): file basename
    '''
    if file_basename[-1] == '/':
        if not os.path.isdir(file_basename):
            print('Creating \'%s\'' % file_basename)
            Path(file_basename).mkdir(parents=True, exist_ok=True)

    else:
        dir_path = '/'.join(file_basename.split('/')[:-1])
        if len(dir_path) != 0:
            if not os.path.isdir(dir_path):   # Check if the directory exists
                print('Creating \'%s\'' % dir_path)
                Path(dir_path).mkdir(parents=True, exist_ok=True)

        else:
            print('Saving files in current directory')

def read_stats_dat(file_path, n_pars, n_header=4, n_line_sep=3):
    '''
    Reads stats.dat file generated by multinest

    Args:
        path (string): file basename
        n_pars (int): number of sampled parameters
        n_header (int): number of lines to skip from the top
        n_line_sep (int): number of lines between data rows


    Returns:
            list: list containing the means, ML and MAP points
    '''

    f = open(file_path, 'r')

    rows = f.readlines()
    f.close()

    read_data = []

    for i in range(3):
        line_num = n_header + i*(n_line_sep+n_pars)
        table = rows[line_num: line_num + n_pars]

        table = [float(item.split()[1]) for item in table]
        read_data.append(table)

    return read_data


def calculate_spec_snr(spec, sky_var):
    spec1D = np.sum(spec, axis=0).flatten()
    var1D = np.sum(sky_var, axis=0).flatten()

    return np.sqrt(np.sum(spec1D**2/(spec1D+var1D)))

def calculate_image_snr(image, var):
    '''
    Calculates the SNR of an image

    Args:
        image (np.ndarray): image data
        var (np.ndarray): variance map

    Returns:
        float: SNR of the image
    '''
    return np.sum(image**2/var)**0.5


def calc_sigma_gplus(ensemble_stats, cut=0, return_weight=False):
    '''
    Returns per-component shape noise
    TO DO: Combine with calc_shape_noise
    '''
    SN, sigma_SN = [], []
    key_list = []

    for key, stat in ensemble_stats.items():
        if cut !=0:
            sigma_g1 = stat.sigma_g1[cut:-cut]
            N = stat.nreal[cut:-cut]  # No. of realizations
            sini = stat.sini[cut:-cut]

        else:
            sigma_g1 = stat.sigma_g1
            N = stat.nreal # No. of realizations
            sini = stat.sini


        s = sigma_g1

        if np.any(N!=1):
            sigma_s = s/(2*(N-1))**0.5
            this_error = np.sqrt(1/np.sum(1/sigma_s**2))

        else:
            this_error = 0.0
            sigma_s = np.ones(len(s))


        weight = 1/sigma_s**2 * np.abs(np.tan(np.arcsin(sini)))
        SN.append(np.sum(s*weight)/np.sum(weight))  # ensemble average
        sigma_SN.append(this_error)

        key_list.append(key)

    if return_weight is True:
            return SN, sigma_SN, np.sum(weight), key_list

    return SN, sigma_SN, key_list


def calc_sigma_gcross(ensemble_stats, cut=0, return_weight=False):
    '''
    Returns per-component shape noise
    TO DO: Combine with calc_shape_noise
    '''
    SN, sigma_SN = [], []
    key_list = []

    for key, stat in ensemble_stats.items():
        if cut !=0:
            sigma_g2 = stat.sigma_g2[cut:-cut]
            N = stat.nreal[cut:-cut]  # No. of realizations
            sini = stat.sini[cut:-cut]

        else:
            sigma_g2 = stat.sigma_g2
            N = stat.nreal # No. of realizations
            sini = stat.sini


        s = sigma_g2

        if np.any(N!=1):
            sigma_s = s/(2*(N-1))**0.5
            this_error = np.sqrt(1/np.sum(1/sigma_s**2))

        else:
            this_error = 0.0
            sigma_s = np.ones(len(s))


        weight = 1/sigma_s**2 * np.abs(np.tan(np.arcsin(sini)))
        SN.append(np.sum(s*weight)/np.sum(weight))  # ensemble average
        sigma_SN.append(this_error)

        key_list.append(key)

    if return_weight is True:
            return SN, sigma_SN, np.sum(weight), key_list

    return SN, sigma_SN, key_list


def calc_shape_noise(ensemble_stats, cut=0, dist='sini', return_weight=False):
    '''
    Returns per-component shape noise
    '''
    SN, sigma_SN = [], []
    key_list = []

    for key, stat in ensemble_stats.items():
        if cut !=0:
            sigma_g1, sigma_g2 = stat.sigma_g1[:cut], stat.sigma_g2[:cut]
            N = stat.nreal[:cut]  # No. of realizations
            sini = stat.sini[:cut]

        else:
            sigma_g1, sigma_g2 = stat.sigma_g1, stat.sigma_g2
            N = stat.nreal # No. of realizations
            sini = stat.sini

        s = (sigma_g1**2 + sigma_g2**2)**0.5/np.sqrt(2)  # sqrt(sigma1**2 + sigma2**2))/sqrt(2)

        if np.any(N!=1):
            sigma_s = s/(2*(N-1))**0.5
            this_error = np.sqrt(1/np.sum(1/sigma_s**2))

        else:
            this_error = 0.0
            sigma_s = np.ones(len(s))

        if dist=='sini':
            weight = 1/sigma_s**2 * np.abs(np.tan(np.arcsin(sini)))
#             tani_int = np.abs(np.cos(np.arcsin(np.abs(sini)+0.0516)) - np.cos(np.arcsin(np.abs(sini)-0.0516)))
#             weight = 1/sigma_s**2 * tani_int

        if dist=='cosi':
            weight = 1/sigma_s**2


        SN.append(np.sum(s*weight)/np.sum(weight))  # ensemble average
        sigma_SN.append(this_error)

        key_list.append(key)

    if return_weight is True:
            return SN, sigma_SN, np.sum(weight), key_list

    return SN, sigma_SN, key_list


def get_lensing_depth(z_source, z_lens):
    '''
    Returns the lensing depth for a given lens and source redshift

    Args:
        z_lens (float): lens redshift
        z_source (float): source redshift

    Returns:
        float: lensing depth
    '''
    # Set cosmology from Umetsu+2014
    omega_m = 0.27
    h = 0.7

    # Calculate the angular diameter distances
    cosmo = FlatLambdaCDM(H0=h*100, Om0=omega_m)
    D_s = cosmo.angular_diameter_distance(z_source).value
    D_ls =  cosmo.angular_diameter_distance_z1z2(z_lens, z_source).value

    return D_ls/D_s


def predcit_shear_from_map(RA, Dec, z_source, z_lens=0.225,method='nfw', path=None, return_error=False):
    '''
    Predicts shear from a map based on the given celestial coordinates and redshifts.

    Parameters:
    - RA (float): Right Ascension in degrees.
    - Dec (float): Declination in degrees.
    - z_lens (float): Redshift of the lens.
    - z_source (float): Redshift of the source.
    - method (str, optional): Method used for prediction. Defaults to 'nfw'.
    - path (str, optional): Path to the gamma maps. Defaults to None.
    - return_error (bool, optional): Whether to return the prediction errors. Defaults to False.

    Returns:
    - gamma1_predict (float): Predicted gamma1 component of the shear.
    - gamma2_predict (float): Predicted gamma2 component of the shear.
    - gamma1_predict_err (float, optional): Prediction error for gamma1 component. Only returned if return_error is True.
    - gamma2_predict_err (float, optional): Prediction error for gamma2 component. Only returned if return_error is True.
    '''
    beta = get_lensing_depth(z_source, z_lens)
    beta_A2261_CLASH = 1.  # Table 3 in Zitrin+2015

    if path is None:
        path = '/xdisk/timeifler/pranjalrs/KL_data/CLASH_gamma_maps'

    gamma1_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma1.fits')
    gamma1_err_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma1-1sigmaerr.fits')

    gamma2_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma2.fits')
    gamma2_err_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma2-1sigmaerr.fits')

    coord = galsim.CelestialCoord(RA*galsim.degrees, Dec*galsim.degrees)
    objpos = gamma1_map.wcs.toImage(coord)

    try:
        gamma1_predict = gamma1_map[objpos.round()] * beta/beta_A2261_CLASH
        gamma1_predict_err = gamma1_err_map[objpos.round()] * beta/beta_A2261_CLASH
        gamma2_predict = gamma2_map[objpos.round()] * beta/beta_A2261_CLASH
        gamma2_predict_err = gamma2_err_map[objpos.round()] * beta/beta_A2261_CLASH

        if return_error is True:
            return gamma1_predict, gamma2_predict, gamma1_predict_err, gamma2_predict_err

        return gamma1_predict, gamma2_predict

    except galsim.errors.GalSimBoundsError:
        print(f'Object out of bounds!')
        if return_error is True:
            return None, None, None, None

        return None, None

def get_PA(coord):
    '''
    Calculate the position angle (PA) between a given coordinate and a reference coordinate.

    Parameters:
    coord (astropy.coordinates.SkyCoord): The coordinate for which the PA needs to be calculated.

    Returns:
    astropy.units.Quantity: The position angle in radians.

    '''
    a2261_RA = 260.612917*u.deg
    a2261_Dec = 32.133889*u.deg

    RA_s, Dec_s = coord.ra.to(u.radian).value, coord.dec.to(u.radian).value
    RA_l, Dec_l = a2261_RA.to(u.radian).value, a2261_Dec.to(u.radian).value

    numerator = (Dec_s - Dec_l)/np.cos((Dec_s+Dec_l)/2)
    denominator = (RA_s - RA_l)

    return np.arctan2(numerator, denominator)*u.radian


def get_distance(coord):
    """
    Calculate the angular separation between the given coordinate and the coordinate of A2261.

    Parameters:
    coord (astropy.coordinates.SkyCoord): Input coordinates.

    Returns:
    float: The angular separation in arcminutes.
    """
    a2261_RA = 260.612917*u.deg
    a2261_Dec = 32.133889*u.deg

    coord_a2261 = SkyCoord(a2261_RA, a2261_Dec)
    dist = coord.separation(coord_a2261)

    return dist.to(u.arcmin)

def get_gammat_diff(R, z_source, z_lens=0.225, path=None):
    '''
    Calculate the difference between two gamma_t maps and return the mean and standard deviation of the difference.

    Parameters:
    z_source (float): Redshift of the source.
    z_lens (float): Redshift of the lens.
    R (float): Radius value.
    path (str): Path to the directory containing the gamma_t maps.

    Returns:
    tuple: A tuple containing the mean and standard deviation of the difference between the two gamma_t maps.
    '''
    if path is None:
        path = '/xdisk/timeifler/pranjalrs/KL_data/CLASH_gamma_maps'

    gamma1_nfw_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-nfw_v2_gamma1.fits')
    gamma2_nfw_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-nfw_v2_gamma2.fits')

    gamma1_ltm_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-ltm-gauss_v2_gamma1.fits')
    gamma2_ltm_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-ltm-gauss_v2_gamma2.fits')

    # Make coordinate grid
    header = fits.open(f'{path}/hlsp_clash_model_a2261_zitrin-nfw_v2_gamma1.fits')[0].header
    wcs = WCS(header)
    x_indices, y_indices = np.meshgrid(np.arange(gamma1_nfw_map.array.shape[1]), np.arange(gamma1_nfw_map.array.shape[1]))
    coord = wcs.pixel_to_world(x_indices, y_indices)  # Pixel indices are 1-based

    phi = get_PA(coord).value
    distance = get_distance(coord).to(u.arcmin).value

    gammat_nfw = -gamma1_nfw_map.array * np.cos(2*phi) + gamma2_nfw_map.array * np.sin(2*phi)
    gammat_ltm = -gamma1_ltm_map.array * np.cos(2*phi) + gamma2_ltm_map.array * np.sin(2*phi)

    # Modify to account for source position
    beta = get_lensing_depth(z_source, z_lens)
    beta_A2261_CLASH = 1.  # Table 3 in Zitrin+2015
    gammat_nfw = gammat_nfw * beta/beta_A2261_CLASH
    gammat_ltm = gammat_ltm * beta/beta_A2261_CLASH

    mask = (distance>(R-0.2)) & (distance<(R+0.2))

    diff = (gammat_nfw-gammat_ltm)[mask]

    return np.mean(diff), np.std(diff)


def get_gammat_var_in_cutout(RA, Dec, R, z_source, z_lens=0.225, method='nfw', path=None):
    '''
    Calculate the variance of gammat in a cutout region.

    Parameters:
    - RA (float): Right Ascension of the target position in degrees.
    - Dec (float): Declination of the target position in degrees.
    - R (float): Radius of the cutout region in arcseconds.
    - z_source (float): Redshift of the source.
    - z_lens (float): Redshift of the lens (default: 0.225).
    - method (str): Method used for calculation (default: 'nfw').
    - path (str): Path to the directory containing gamma maps (default: None).

    Returns:
    - float: Standard deviation of gammat in the cutout region.
    '''
    if path is None:
        path = '/xdisk/timeifler/pranjalrs/KL_data/CLASH_gamma_maps'

    gamma1_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma1.fits')
    gamma2_map = galsim.fits.read(f'{path}/hlsp_clash_model_a2261_zitrin-{method}_v2_gamma2.fits')

    coord = galsim.CelestialCoord(RA*galsim.degrees, Dec*galsim.degrees)
    objpos = gamma1_map.wcs.toImage(coord)
    pix_x, pix_y = int(objpos.x), int(objpos.y)

    phi = get_PA(coord).to(u.radian).value

    gammat = -gamma1_map.array * np.cos(2*phi) + gamma2_map.array * np.sin(2*phi)

    # Modify to account for source position
    beta = get_lensing_depth(z_source, z_lens)
    beta_A2261_CLASH = 1.
    gammat = gammat * beta/beta_A2261_CLASH

    PIX_SCALE = 0.065 # arcsec/pixel
    R_pix = int(R/PIX_SCALE)

    gammat_cutout = gammat[pix_y-R_pix:pix_y+R_pix, pix_x-R_pix:pix_x+R_pix]

    return np.std(gammat_cutout)


def build_1d_grid(Nx, pix_scale):
    # max distance in given direction
    # even pixel counts requires offset by 0.5 pixels
    Rx = (Nx // 2) - 0.5 * ((Nx-1) % 2)
    return np.arange(-Rx, Rx+1, 1)*pix_scale


def build_map_grid(Nx, Ny, pix_scale):
    '''
    From Spencer's kltools.utils
    We define the grid positions as the center of pixels

    For a given dimension: if # of pixels is even, then
    image center is on pixel corners. Else, a pixel center
    '''
    x = build_1d_grid(Nx, pix_scale)
    y = build_1d_grid(Ny, pix_scale)

    assert len(x) == Nx
    assert len(y) == Ny

    X, Y = np.meshgrid(x, y, indexing='ij')

    X, Y = X, Y

    return X, Y
